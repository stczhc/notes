
.. only:: html

    .. math::
        \renewenvironment{equation*}
        {\begin{equation}\begin{aligned}}
        {\end{aligned}\end{equation}}
        \renewcommand{\gg}{>\!\!>}
        \renewcommand{\ll}{<\!\!<}
        \newcommand{\I}{\mathrm{i}}
        \newcommand{\D}{\mathrm{d}}
        \renewcommand{\C}{\mathrm{C}}
        \newcommand{\dt}{\frac{\D}{\D t}}
        \newcommand{\E}{\mathrm{e}}
        \renewcommand{\bm}{\boldsymbol}
        \require{mediawiki-texvc}

.. note::
    https://quimb.readthedocs.io/en/latest/tensor-algorithms.html

MPS 形式的 DMRG
===============

初始化
------

首先构造 MPO 的显式形式, MPS 随机. 然后如果第一步扫描是向右扫描, 那么要把 MPS 变成右正则形式. 这和普通态的右正则化不太一样, 实际不是 SVD 而是 LR 分解.

也就是说, 一开始的态是

.. code::

       2  2  2  2
       |10|10|10|
    ...o--o--o--o

从最右边的张量开始, 每次把 上指标 (2) 和右指标 (bond, 若有) 集合为矩阵的右指标, 左指标为矩阵的左指标. 然后进行 LQ 分解.
比如, 对最右边, 这是 10 x 2 矩阵, 因此得 L(10 x2) . Q(2x2) 其中 Q 正交. 然后把 L 乘到左边, 于是最右边键长变为了 2. 左边的矩阵 LL(10x2x10) . L(10x2) = NEWL(10x2x2). 即

.. code::

       2  2  2 2
       |10|10|2|
    ...o--o--o-o

再对倒数第二个做相同的操作. 此时 LQ 分解的是 LQ(10x4) = L(10x4) . Q(4x4). 于是倒数第二个键长变为了 4.

当右边两个指标乘积超过 10 时, 例如, 2x8 = 16, LQ 分解的是 LQ(10x16) = L(10x10) . Q(10x16). 这里 Q 仍正交的意义是 Q(10x16) x (16x10) = delta(10x10).

正交的理解
----------

注意第一步得到的正交很好理解, 即

.. code::

    i--o   i--
       | =   | = delta(ij)
    j--o   j--

对第二步, 我们有

.. code::

    i--o--o   i--o--
       |  | =   k| |m
    j--o--o   j--o--

其中第一个等号利用了已知的最右边两个张量已经正交的关系. 然后倒数第二个张量直接用线连起来什么意思呢, 这就是说要对那两个指标做内指标求和. 即现在求 :math:`A_{ikm}A_{jkm}`. 这相当于将 :math:`km` 指标求直积得到一个合并指标, 然后把矩阵看成这个合并矩阵, 然后如果对 :math:`km` 指标求和, 得到的是 :math:`\delta_{ij}`. 注意只有当最右边已经正交时, 我们才有这个解释. 因此即使那个合并的指标超过 bond dim, 也还是可以按照 :math:`A(10x16)xA(16x10) = I(10x10)` 解释为正交.

对最左边的态不需要任何操作.

每次对 ket 操作完之后, 再将 bra 中的每个矢量设置为 ket 中对应矢量的共轭.

扫描步骤
--------

环境块的准备工作
^^^^^^^^^^^^^^^^

但是如果上一步正好是反向扫描的, 则不需要正交化.

下面的步骤是逐渐将态和算符缩并, 也就是缩并 i 指标, 和 M 指标无关. 实际上在 DMRG 传统算法中, 只用到缩并后的形式.

在 2dot 的情况, 假定一共有 40 个位点, 标为 0..39. 那么需要构建 0..38 个扫描步骤. 其中 env 也是包括 dots 的. 因此第 38 步骤的环境包括位点 38-39, 但是没有缩并. 第 37 步骤的环境包括位点 37, 38, 39, 但是 39 位点的 ket, bra, H 要进行缩并. 称为缩并的 39. 至于 37, 38 因为是独立的位点所以不管他. 第 36 步骤, 要把 38 位点缩并, 并和缩并的 39 一起缩并. 这些操作并不会累积 bond dim. 至多也就是 k^2M^2. 在 ``init_segment (/Users/fszix/Projects/quimb-1.2.0/quimb/tensor/tensor_dmrg.py:290)`` 中是通过 dummy 张量 ``_RIGHT`` 来控制把这些张量全部缩并在一起.

按这个理解, 第 38 扫描步骤, 有 2*3 + 1 = 7 个张量. 第 37 则有 7 + 3 - 3 = 7. 因此一直都有 7 个张量.

这个步骤在原始 DMRG 算法中是逐块进行的, 不会在一开始就把右边的环境块准备好.

因此最后一个扫描步骤 (步骤 38) 的网络是

.. code::

    o--o--o ... --o--o--*--*
    |  |  | ...   |  |  |  |
    o--o--o ... --o--o--*--*
    |  |  | ...   |  |  |  |
    o--o--o ... --o--o--*--*
    0  1  2 ...  36 37 38 39

其中 ``*`` 表示包括在环境块中的张量

倒数第二个扫描步骤 (步骤 37) 的网络是

.. code::

    o--o--o ... --o--*--*
    |  |  | ...   |  |  |\
    o--o--o ... --o--*--*-$
    |  |  | ...   |  |  |/
    o--o--o ... --o--*--*
    0  1  2 ...  36 37 38

其中 ``$`` 由三个 ``*`` 缩并而来.

倒数第三个扫描步骤 (步骤 36) 的网络是

.. code::

    o--o--o ... --*--*
    |  |  | ...   |  |\
    o--o--o ... --*--*-$
    |  |  | ...   |  |/
    o--o--o ... --*--*
    0  1  2 ...  36 37

第 0 个扫描步骤的网络是 (步骤 0)

.. code::

    *--*
    |  |\
    *--*-$
    |  |/
    *--*
    0  1

这些标为 ``*`` 和 ``$`` 的环境块储存在 ``self.env`` (``tensor_dmrg.py L 292``).

开始移动
^^^^^^^^

这里 MoveEnviron 里面是用 ``self.pos`` 来标记当前位置的. 而 move_right 或者 move_left 则是具体执行一次 move. 第一次 pos = 0, 而 i = 0 因此什么也没做. 但是第一个env 添加了一个 left 的空块. 然后调用 ``_update_local_state_2site (/Users/fszix/Projects/quimb-1.2.0/quimb/tensor/tensor_dmrg.py:785)``.

在 ``parse_2site_inds_dims`` 里面, ``u.bond.ind`` 和 ``l.bond.ind`` 分别是 ket 和 bra 的两个独立位点相连接的 bond 指标. ``dims_L, uix_L`` 是左边的位点的其他指标的维数和指标名. ``dims_R, uix_R`` 是右边的位点的.

假定上面的是 ket, 下面的 bra. uix 也就是 ket 的 index 的意思. lix 是 bra 的 index 的意思.

然后就是构建超块哈密顿量. 这个在 ME 的 ``self.ME_eff_ham()``.

本来只要把整个网络全部缩并就得到能量. 但是波函数是随机的. 因此要把 lcoal 位点的 ket 和 bra 剥离出, 求剩余的部分的哈密顿量. 这个哈密顿量的指标就正好是 lix, uix. 这就是 L673 做的事情.

这样就得到了超块哈密顿量. 剩余的部分是 local 的 sites ket 和 bra. 把其中两个 bra 缩并作为 eigen 求解的初始值.

然后求解本征值问题. 得到的 ket 是合并指标的, 再按照 uix 的细分指标弄成张量. 然后把这个张量左边部分弄成正交的. 即 *-* = L-R 其中 L 是左正交的. 然后把 LR 及其共轭插进 两个 site 的网络.

这就完成了第一步 blocking.

注意这里那两个独立位点还是散的.

第二步移动
^^^^^^^^^^

第二步移动一开始要缩并最左边的节点. 实际上, 第一个 env 块包括了完整的网络和 一个 dummy LEFT. 第二个 env 块一开始不包括 LEFT 也不包括最左边的三个. 我们要做的就是, 把前一个 env 块中的 LEFT 和 第 0 位点的 H KET, BRA 一起缩并, 作为新的 LEFT, 插入到 第 1 步骤的 env 中, 这样这个 env 就有了 dummy 的 LEFT, 并且完整了.

一些思考
--------

注意所谓的 MPS 其实是一个基组, 并不是仅仅一个态. 传统 DMRG 最开始时是从 一个大小为 1 的块开始的, 这个 MPS 部分右边有一个 bond dim, dim = 2. 实际上如果这个 MPS 随机取, 不如取为 单位矩阵. 那么相当于 DMRG 在一开始选取最自然的基组. 但是这对于后面的情况无法处理. 然后所谓的 算符都是表示在这个基组中的.

还有一个就是最开始的环境如何选择. 需要去看 DMRG 的原始代码.
